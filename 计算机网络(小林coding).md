# 计算机网络(小林coding)

**[小林图解网络](https://xiaolincoding.com/network/1_base/tcp_ip_model.html#网络层)**

## 一、基础篇

### 1.1 TCP/IP网络模型有哪几层

**为什么要有TCP/IP网络模型？**

同一台设备的进程间通信有许多方式（管道、消息队列、共享内存、信号等方式），对于不同设备上的进程间通信，就需要网络通信。但设备是多样性的，所以要兼容多种多样的设备，就协商出了一套通用的网络协议。

该网络协议是分层的，每一层都有各自的作用和职责。

#### 1.1.1 应用层

应用层（Applicantion Layer）是最上层的且也是我们最能直接接触到的，电脑、手机的应用软件都是在应用层实现的。两个不同设备的应用需要通信时，就把应用数据传给下一层，即传输层。

应用层只需要专注为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等。

应用层工作在操作系统中的用户态，传输层及以下则工作在内核态。

#### 1.1.2 传输层

传输层接收应用层的数据包，为应用层提供网络支持。

两个传输协议：

- TCP：传输控制协议(Transmission Control Protocol)，TCP相比UDP多了很多特性，比如流量控制、超时重传、拥塞控制登，都是为了保证数据包能可靠地传输给对方。
- UDP：只负责发送数据包，但不保证数据包是否能抵达对方，实时性相对更好，传输效率也高。UDP也可以实现可靠传输，只需要把TCP的特性在应用层上实现即可。

应用需要传输的数据可能会非常大，如果直接传输不好控制。要因此但传输层的数据包大小超过MSS(TCP最大报文段长度)，就要将数据包分块，即使中途有一个分块丢失或损坏，也只需要重发这一分块，不用重发整个数据包。在TCP协议中，每一个分块称为TCP段(TCP Segment)。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png)

当设备作为接收方时，传输层负责把数据包传给应用，但一台设备可能会有多个应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**。

80端口通常是Web服务器用的，22端口通常是远程登录服务器用的。对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。

由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。

#### 1.1.3 网络层

如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层负责这一块功能就违背设计原则了。

网络层承担实际的传输功能。

网络层最常使用的是IP协议(Internet Protocol)，IP协议会将传输层的报文作为数据部分，再加上IP包头组装成IP报文，如果IP报文大小超过MTU（以太网中一般为1500字节）就会再次进行分片，得到一个即将发送到网络的IP报文。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

网络层负责将数据从一个设备传输到另一个设备，世界上如此多的设备，该如何找到对应设备？因此，网络层需要有区分设备的编号。

一般用IP地址给设备进行编号，对于IPv4协议，IP地址共32位，分成了四段(比如192.168.100.1)，每段八位，只有一个单纯的IP地址虽然做到了区分设备，但是寻址起来十分麻烦，不可能去和全部设备一一匹配。

因此，IP地址有两种意义：

- 一个是网络号，负责标识该IP地址是属于哪个[子网]的
- 一个是主机号，负责标识同一[子网]下的不同主机

如何区分网络号和主机号？需要配合子网掩码才能计算出IP地址的 网络号 和 主机号

举个例子，比如 10.100.122.0/24，后面的`/24`表示就是 `255.255.255.0` 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，共 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。

知道了子网掩码，该怎么计算出网络地址和主机地址呢？

将 10.100.122.2 和 255.255.255.0 进行**按位与运算**，就可以得到网络号，如下图：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg)

将 255.255.255.0 取反后与IP地址进行进行**按位与运算**，就可以得到主机号。

![子网掩码计算器](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E5%99%A8.png)

在寻址过程中，先匹配到相同的网络号（表示要找到用一个子网），再去找对应的主机。

除了寻址能力，IP协议还有另一个重要的能力就是路由。两台设备并不是单纯通过一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，因此会形成很多条网络的路径。路由器寻址工作中，就是要找到目标地址的子网，进而把数据包转发给对应的网络。

IP协议的寻址作用是给予下一个目的地的方向，路由根据IP地址选择路径。寻址像导航、路由像操作方向盘。

![IP地址的网络号](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg)

#### 1.1.4 网络接口层

网络层生成IP头部后，交给网络接口层（Link Layer），在IP头部前面加上MAC头部，并封装成数据帧（Date frame）发送到网络上

IP头部中的接收方IP地址表示网络包的目的地，通过这个地址可以判断把数据包发到哪里，但是在以太网的世界中，这个思路行不通

**以太网：**

电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术。

以太网在判断网络包目的地时和IP的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而MAC头部正好起到该作用。所以要在以太网进行通讯要用到MAC地址。

MAC头部是以太网使用的头部，包含了接收方和发送方的MAC地址等信息，可以通过ARP协议获取对方的MAC地址。

网络接口层主要为网络层提供**链路级别**传输的服务，负责在以太网、WiFi这样的底层网络上发送原始数据包，工作在网卡这个层次，使用MAC地址，来标识网上的设备。



**总结：**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png)

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png)

网络接口层的传输单位是帧（frame），IP层的传输单位是包（packet），TCP层的传输单位是段（segment），HTTP传输单位是消息或报文（message）。但这些没有本质的区分，统称为数据包。

### 1.2 键入网址到网页显示，期间发生了什么

#### 1.2.1 HTTP

![简单的网络模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg)

1. 浏览器做的第一步工作就是对URL进行解析，从而生成发送给Web服务器的请求信息

   ![URL 解析](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg)

   所以URL实际上是请求服务器里的文件资源。

   没有路径名时，就代表访问根目录下事先设置的默认文件，即/index.html或者/default.html

2. 对URL进行解析后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息生成HTTP请求报文

   ![HTTP 的消息格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)

#### 1.2.2 DNS-真实地址查询

通过浏览器解析URL并生成HTTP报文后，需要委托操作系统将消息发给Web服务器。

但在发送之前，还有一项工作需要完成，即查询服务器域名对应的IP地址，因为委托操作系统发送消息时，必须提供通信对象的IP地址

打个比方，联系对方时，我们必须要知道对方的电话号码，但电话号码不方便记忆，因此将电话号码和联系人的姓名保存在通讯录中。

因此，有一种服务器专门保存了Web服务器域名与IP的对应关系，即DNS服务器

**域名的层级关系：**

DNS的域名用dot分割，例如www.server.com，这里的句点代表了不同层级之间的界限，在域名中，越靠右的位置表示层级越高。

实际上域名最后还有一个点，www.server.com. 最后一个点代表根域名，所以从上到下是，.跟域 -> .com顶级域 -> server.com，类似一个树状结构

![DNS 树状结构](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg)

跟域的DNS服务器信息保存在互联网总所有的DNS服务器中，因此任何DNS服务器都可以找到并访问根域DNS服务器了。

所以客户端只要能找到任意一台DNS服务器，就可以通过它找到根域DNS服务器，然后再一路顺藤摸瓜找到位于下层的某台目标DNS服务器

**域名解析的工作流程：**

1. 客户端首先发出一个DNS请求，请求目标域名的IP地址，并发给本地DNS服务器（即客户端TCP/IP设置中填写的DNS服务器地址）
2. 本地域名服务器接收到客户端的请求后，如果缓存中的表格能找到域名，则直接返回其IP地址。如果没有，本地DNS就去询问其根域名服务器请求目标域名的IP地址，根域名服务器是最高层次的，不直接用于域名解析，但是能够指明方向
3. 根DNS收到来自本地DNS的请求后，发现后置是.com，归.com区域管理，因此返回.com顶级域名服务器地址
4. 本地DNS收到顶级域名服务器地址后，向顶级域名服务器询问目标域名的IP地址
5. 顶级域名服务器返回负责目标域名(www.server.com)的权威DNS服务器地址
6. 本地DNS于是转向权威DNS服务器，询问目标域名的IP地址，server.com的权威DNS服务器是域名解析结果的原出处。权威-我的域名我作主
7. 权威DNS服务器查询后将对应的IP地址X.X.X.X告诉给本地DNS
8. 本地DNS再将IP地址返回给客户端，客户端与目标建立连接

![域名解析的工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)

DNS域名解析过程只指路但不带路

并不是每次域名解析都要经过这样的过程，因为我们还有缓存

浏览器会先看自身有没有对当前目标域名的缓存（里面直接存着IP地址），如果有，直接返回，没有就去问操作系统，操作系统也会看自己的缓存，如果有也直接返回，没有再去hosts文件看，如果还没有，才回去问本地服务器。

所以流程大概是：浏览器缓存 -> 操作系统缓存 -> hosts文件

#### 1.2.3 协议栈-指南针

通过DNS获取到IP地址后，就可以把HTTP报文的传输工作交给操作系统中的协议栈。

协议栈内部分为几个部分，分别承担不同的工作。上下关系有一定规则，上面部分会向下面发布任务，下面部分接收到上面委托并执行

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg)

应用程序（浏览器）通过调用Socket库，来委托协议栈工作。协议栈上半部分有两块，分别是负责收发数据的TCP和UDP协议，这两个传输协议会接受应用层的委托执行收发数据的操作。协议栈的下半部分用IP协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由IP负责的。

IP中还包括ICMP协议和ARP协议：

- ICMP用于告知网络包传输过程中产生的错误以及各种控制信息
- ARP用于根据IP地址查询相应的以太网MAC地址

IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡负责完成实际的收发操作，即对网线中的信号执行发送和接收操作

#### 1.2.4 TCP-可靠传输

HTTP是基于TCP协议传输的

**TCP包头格式：**

![TCP 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg)

- 源端口号和目标端口号是必不可少的，没有这两个端口号，数据就不知道应该从哪个应用发送到哪个应用

- 包的序号是为了解决包乱序的问题

- 确认序列是为了确认发出去对方是否有收到，如果没有收到就应该重新发送，直到送达，解决丢包问题

- 接下来是状态位:

  1. SYN：发起一个连接
  2. ACK：回复
  3. RST：重新连接
  4. FIN：结束连接

  TCO是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方状态的变更

- 窗口大小，TCP要做到流量控制，通信双方各声明一个窗口（缓存大小），标识自己当前能够处理数据包的能力，保证合适的发送速率，即别太快，也别太慢。除了做流量控制之外，TCP还会做拥塞控制，控制发送速度，尽量不让网络通路塞车

**TCP传输数据之前，要先三次握手建立连接**

在HTTP传输数据之前，首先要建立TCP连接，TCP连接的建立，通常称为三次握手。

所谓的连接，其实只是双方计算机里维护一个状态机，在建立连接的过程中，双方的状态变化时序图如果下图。

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

- 一开始，客户端和服务端都处于CLOSED状态。显示服务器主动监听某个端口，处于LISTEN状态
- 然后客户端主动发起连接SYN，之后处于SYN-SENT状态
- 服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态
- 客户端收到服务端发送的SYN和ACK之后，发送对SYN确认的ACK，之后处于ESTABLISHED状态，因为它一发一收成功了
- 服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为它也一发一收了

因此**三次握手的目的是保证双方都有发送和接收的能力**

**查看TCP的连接状态**

在Linux可以通过netstat -napt命令查看

![TCP 连接状态查看](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/10.jpg)

**TCP分割数据**

如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。

![MTU 与 MSS](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg)

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。

![数据包分割](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

**TCP报文生成**

TCP协议里面有两个端口，一个是浏览器监听的端口（通常是随机生成的），另一个是Web服务器监听的端口（HTTP默认端口号是80，HTTPS默认端口号是443）

在双方建立连接后，TCP报文中的数据部分就是存放HTTP头部+数据，组装好TCP报文之后，就需要交给下面的网络层处理

![TCP 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg)

到此，数据包就有了TCP的保驾护航，但是仍不知道该往哪里走

#### 1.2.5 IP-远程定位

TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成网络包发送给通信对象

IP报文头部格式：

![IP 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg)

- IP协议里需要有源地址IP（客户端输出的IP地址）和目标地址IP（通过DNS域名解析得到的Web服务器IP）
- 因为HTTP是经过TCP传输的，所以在IP包头的协议号，要填写为06（十六进制），表示协议为TCP

**假设客户端有多个网卡，就会有多个IP地址，那IP头部的源地址应该选择哪个IP**

当存在多个网卡时，在填写源地址IP时，需要判断应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个网卡来发送包

需要根据路由表规则来判断使用哪一个网卡来作为源地址IP

在Linux操作系统中，可以使用route -n指令来查看当前系统的路由表

![路由规则判断](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/16.jpg)

1. 首先先和第一条目的子网掩码（`Genmask`）进行 **与运算**，得到结果为 `192.168.10.0`，但是第一个条目的 `Destination` 是 `192.168.3.0`，两者不一致所以匹配失败。
2. 再与第二条目的子网掩码进行 **与运算**，得到的结果为 `192.168.10.0`，与第二条目的 `Destination 192.168.10.0` 匹配成功，所以将使用 `eth1` 网卡的 IP 地址作为 IP 包头的源地址。

那么假设 Web 服务器的目标地址是 `10.100.20.100`，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。

第三条目比较特殊，它目标地址和子网掩码都是 `0.0.0.0`，这表示**默认网关**，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，`Gateway` 即是路由器的 IP 地址。

**IP报文生成**

![IP 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/17.jpg)

至此，目的地已经知道了，但是太过遥远，数据包需要知道当前下一步应该去哪里

#### 1.2.6 MAC-两点传输

生成IP头部之后，接下来网络包还需要再IP头部前面加上MAC头部

**MAC包头格式**

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。

![MAC 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg)

在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

- `0800` ： IP 协议
- `0806` ： ARP 协议

**MAC发送方和接收方如何确认**

发送方的MAC地址比较简单，MAC地址是在网卡生产时写入到ROM里的，只要将这个值读取出来写入到MAC头部即可

接收方的MAC地址些许复杂，只要告诉以太网对方的MAC的地址，以太网就会帮我们把数据包发送过去，因此显然这里需要填写对方的MAC地址

所以先得搞清楚应该把包发给谁，这个只要查一下**路由表**就知道了。在路由表中找到相匹配的条目，然后把包发给 `Gateway` 列中的 IP 地址就可以了。



小插曲：在这里我一直有个疑惑，为什么有了IP地址还需要MAC地址？

解答：IP地址和MAC地址都是计算机网络中用于标识和定位设备的地址，但它们的作用不同。

IP地址是一种逻辑地址，用于标识网络中的设备和进行网络通信。在互联网中，每台设备都必须拥有一个唯一的IP地址，以便在网络中进行通信。

而MAC地址是一种物理地址，是指与网络接口卡（NIC）绑定的地址。在网络中，MAC地址用于在局域网中唯一标识设备。通过MAC地址，网络设备可以识别其他设备，并在局域网中进行通信。

因此，IP地址和MAC地址在网络中扮演不同的角色，IP地址用于进行网络通信，而MAC地址用于在局域网中唯一标识设备。尽管设备已经拥有IP地址，但在局域网中，MAC地址仍然是必需的，因为在局域网中，通信是通过MAC地址进行的。

总结：IP地址是在大范围互联网寻找相应子网的，而MAC地址用于小范围局域网找到对应设备



**如何获取对方的MAC地址**

需要ARP协议帮助我们找到路由器的MAC地址

![ARP 广播](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg)

如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。

在后续操作系统会把本次查询结果放到一块叫做 **ARP 缓存**的内存空间留着以后用，不过缓存的时间就几分钟。

也就是说，在发包时：

- 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。

**查看ARP缓存内容**

在 Linux 系统中，我们可以使用 `arp -a` 命令来查看 ARP 缓存的内容。

![ARP 缓存内容](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/20.jpg)

**MAC报文生成**

![MAC 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg)

至此，数据包已经知道自己下一步要去往哪里了，准备出发了。

#### 1.2.7 网卡-出口

网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，需要将数字信息转换为电信号，才能在网线上传输，这才是真正的数据发送过程

负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序

网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头上加上报文和起始帧分界符，在末尾加上用于检测错误的帧校验序列。

![数据包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png)

- 起始帧分界符是一个用来表示包起始位置的标记
- 末尾的 `FCS`（帧校验序列）用来检查包传输过程是否有损坏

#### 1.2.8 交换机-送别者

交换机的设计是将网络包原样转发到目的地。交换机工作在MAC层，也称为二层网络设备



**交换机的包接收操作**

1. 首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号

2. 然后通过包末尾的FCS校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同

3. 计算机的网卡本身具有MAC地址，并通过核对收到的包的接收方MAC地址判断是不是发给自己的，如果不是则丢弃。相对的，交换机的端口不核对接收方的MAC地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有MAC地址

4. 将包存入缓冲区后，接下来需要查询一下这个包的接收方MAC地址是否已经在MAC地址表中已有记录

   交换机的 MAC 地址表主要包含两个信息：

   - 一个是设备的 MAC 地址，
   - 另一个是该设备连接在交换机的哪个端口上。

   ![交换机的 MAC 地址表](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg)

   举个例子，如果收到的包的接收方 MAC 地址为 `00-02-B3-1C-9C-F9`，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 `3` 号端口上，然后就可以通过交换电路将包发送到相应的端口了。所以，**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**。



**当MAC地址表找不到指定的MAC地址时**

地址表中找不到指定的MAC地址，可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被地址表删除了

此种情况下，交换机无法判断应该把包转发到哪个接口，只能将包转发到除了源端口之外的所有端口上，无论设备连接在哪个端口上都能接收到这个包

所以，**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**。

此外，如果接收方 MAC 地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。

以下两个属于广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

至此，数据包通过交换机抵达了路由器，准备离开土生土长的子网了。

#### 1.2.8 路由器-出境大门

**路由器与交换机的区别**

网络包经过交换机之后，到达了路由器，并在此被转发到了下一个路由器或目标设备。

这一步转发的工作原理和交换机相似，但还是有区别的

- 路由器是基于IP设计的，俗称三层网络设备，路由器的各个端口都具有MAC地址和IP地址
- 交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有MAC地址



**路由器基本原理**

路由器的端口具有MAC地址，因此它能够成为以太网的发送方和接收方，同时还具有IP地址，从这个意义上来说，它和计算机的网卡是一样的

当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网发送出去



**路由器的包接收操作**

1. 首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。
2. 电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。

总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。

和交换机的包接收类似



完成包接收操作之后，路由器就会**去掉**包开头的 MAC 头部。

**MAC 头部的作用就是将包送达路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会**被丢弃**。

接下来，路由器会根据 MAC 头部后方的 `IP` 头部中的内容进行包的转发操作。



转发操作分为几个阶段，首先是查询**路由表**判断转发目标。

![路由器转发](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg)

假设地址为 `10.10.1.101` 的计算机要向地址为 `192.168.1.100` 的服务器发送一个包，这个包先到达图中的路由器。

判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。

路由匹配和前面讲的一样，每个条目的子网掩码和 `192.168.1.100` IP 做 **& 与运算**后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。

如第二条目的子网掩码 `255.255.255.0` 与 `192.168.1.100` IP 做 **& 与运算**后，得到结果是 `192.168.1.0` ，这与第二条目的目标地址 `192.168.1.0` 匹配，该第二条目记录就会被作为转发目标。

实在找不到匹配路由时，就会选择**默认路由**，路由表中子网掩码为 `0.0.0.0` 的记录表示「默认路由」。



**路由器的发送操作**

接下来就会进入包的**发送操作**。

首先，我们需要根据**路由表的网关列**判断对方的地址。

- 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，**还未抵达终点**，还需继续需要路由器转发。
- 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明**已抵达终点**。

知道对方的 IP 地址之后，接下来需要通过 `ARP` 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。

路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。

接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 `0800` （十六进制）表示 IP 协议。

网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。

发送出去的网络包会通过**交换机**到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。

接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。

不知你发现了没有，在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

#### 1.2.9 服务器与客户段

![网络分层模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg)

数据包抵达服务器后，服务器就会先扒开数据包的MAC头部，查看是否和服务器自己的MAC地址符合，符合就接收包

接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。

于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP 头部里面还有端口号， HTTP 的服务器正在监听这个端口号。

于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。

服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。

HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。

穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。

最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。

客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！

于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！

最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。



交换机：可以简单理解成一个设备，三台电脑通过网线连接到这台设备，这三台电脑就可以互相通信了，交换数据

Mac 地址只能是两个设备之间传递时使用的，如果你要从大老远给我发消息，是离不开 IP 地址的。



### 1.3 Linux系统是如何收发网络包的

#### 1.3.1 **网络模型**

为了使得多种设备能够通过网络相互通信，和为了解决不同设备在网络互联中的兼容性问题，国际标准化组织制定了开放式系统互联通信参考模型（Open System Interconnection Reference Model）即OSI网络模型，该模型主要有7层，分别是应用层、表示层、会话层、传输层、网络层、数据链路层及物理层。

- 应用层：负责给应用程序提供统一的接口
- 表示层：负责把数据转换成兼容另一个系统能识别的格式
- 会话层：负责建立、管理和终止表示层实体之间的通信会话
- 传输层：负责端到端的数据传输
- 网络层：负责数据的路由、转发、分片
- 数据链路层：负责数据的封帧和差错检测，以及MAC寻址
- 物理层：负责在物理网络中传输数据帧

由于OSI模型过于复杂，提出的也只是概念上理论上的分层，并没有提供具体的实现方案

事实上，比较常见的是四层模型，即TCP/IP网络模型，Linux系统正是按照这套网络模型来实现网络协议栈的

TCP/IP网络模型公有4层，分别是应用层、传输层、网络层和网络接口层，每一层负责的职能如下：

- 应用层：负责向用户提供一组应用程序，比如HTTP、DNS、FTP等
- 传输层：负责端到端的通信，比如TCP、UDP等
- 网络层：负责网络包的封装、分片、路由、转发，比如IP、ICMP等
- 网络接口层：负责网路包在物理网络中的传输，比如网络包的封帧、MAC寻址、差错检测，以及通过网卡传输网络帧等

TCP/IP网络模型比OSI网络模型简化了不少，也更加容易记住，关系如下图所示：
![image-20230523173921088](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230523173921088.png)

常说的七层和四层负载均衡，使用OSI网络模型来描述的，七层对应的是应用层，四层对应的是传输层



#### 1.3.2 Linux网络协议栈

- 应用层中的数据：身体
- 传输层中的TCP头：打底衣服
- 网络层中的IP头：外套
- 网络接口层的帧头和帧尾：帽子和鞋子

把TCP协议通信的网络包发出去时，会把应用层的数据按照网络协议栈层层封装和处理，好比从家里出去时，先穿个打底衣服，再套上外套，最后穿上帽子和鞋子出门

![image-20230524000033732](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230524000033732.png)

- 传输层：给应用数据前面添加TCP头
- 网络层：给TCP数据包前面添加IP头
- 网络接口层：给IP数据包前后分别添加帧头和帧尾

这些新增的头部和尾部都有各自的作用，都是按照特定的协议格式填充，每一层都增加了各自的协议头，自然网络包大小就增大了，但物理链路并不能传输任意大小的数据，所以在以太网中，规定了最大传输单元（MTU）是1500字节，即规定了单词传输的最大IP包大小

当网络包超过MTU的大小，就会在网络层分片，确保分片后的IP包不会超过MTU大小，如果MTU越小，需要的分包就越多，网络的吞吐能力就越差，相反，如果MTU越大，需要的MTU分包就越少，网络的吞吐能力也就越好

Linux网络协议栈的样子类似于TCP/IP的四层结构：
![image-20230529002319281](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230529002319281.png)

从上图的网络协议栈可以看出：

- 应用程序需要通过系统调用，来跟Socket层进行数据交互
- Socket层的下面就是传输层、网络层和网络接口层
- 最下面的一层则是网卡驱动程序和硬件网卡设备



**Linux接收网络包的流程**

网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过DMA技术，将网络包写入到指定的内存地址，也就是写入到Ring Buffer，这是一个环形缓冲区，接着就会高速操作系统这个网络包已经到达。

> 如何告诉操作系统这个网络包已经到达？

最简单的一种方式就是触发中断，即每当网卡收到一个网络包，就出发一个中断告诉操作系统。

但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，因此就会触发十分多的中断，当CPU收到了中断，就会停下手里的事情，然后去处理这些网络包，处理完毕后，才会回去继续其他事情，如此频繁地触发中断，则会导致CPU一直没完没了地处理终端，而导致其他任务可能无法继续前进，从而影响系统的整体效率。

所以为了解决频繁中断带来的性能开销，Linux内核在2.6版本引入NAPI机制，其混入 中断和轮询 的方式来接收网络包，它的核心理念就是不采用中断的方式读取数据，而是首先采用中断环形数据接收的服务程序，然后用 poll 的方法来轮询数据。

因此，当有网络包到达时，会通过DMA技术，将网络包写入到指定的内存地址，接着网卡向CPU发起硬件中断，当CPU收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。

硬件中断处理函数会做如下事情：

- 需要先 暂时屏蔽中断，表示已经知道内存中有数据，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知CPU了，这样可以提高效率，避免CPU不停第被中断
- 接着，发起 软中断 ，然后恢复刚才屏蔽的中断

至此，硬件中断处理函数的工作就已经完成了。

硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。

> 软中断的处理

内核中的ksoftirqd线程专门负责软中断的处理，当ksoftirqd内核线程收到软中断后，就会来轮询处理数据。

ksoftirqd线程会从Ring Buffer中获取一个数据帧，用sk_buff表示，从而可以作为一个网络包交给网络协议栈进行逐层处理，即封装各种协议栈帧头

> 网络协议栈

首先，进入网络接口层，在这一层检查报文的合法性，如果不合法就丢弃，合法则会找出该网络包的上层协议类型，比如是IPv4还是IPv6，接着再去掉帧头和帧尾，然后交给网络层。

到了网络层，则取出IP包，判断网络包的下一步走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从IP头里看看上一层协议的类型是TCP还是UDP，接着去掉IP头，然后交给传输层

传输层取出TCP头或UDP头，根据四元组[源IP、源端口、目的IP、目的端口]作为标识，找出对应的Socket，并把数据放到Socket的接收缓冲区。

最后，应用程序调用Socket接口，将内核的Socket接收缓冲区的数据拷贝到应用层的缓冲区，然后唤醒用户进程。

![image-20230601165046340](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230601165046340.png)

左边是网络包接受过程，右边是网络包发送过程



**Linux发送网络包的流程**

首先，应用程序调用Socket发送数据包的接口，由于是系统调用，所以会从用户态陷入到内核态中的Socket层，内核会申请一个内核态的sk_buff内存，将用户待发送的数据拷贝到sk_buff内存，并将其加入到发送缓冲区

接下来，网络协议栈从Socket发送缓冲区中取出sk_buff，并按照TCP/IP协议栈从上到下逐层处理

如果使用的是TCP传输协议发送数据，那么先拷贝一个新的sk_buff副本，因为sk_buff在后续调用网络层，最后到达网卡发送完成的时候会被释放掉。而TCP协议是支持丢失重传的，在收到对方ACK之前，这个sk_buff不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是sk_buff的一个拷贝，等收到ACK再真正删除。

接着，对sk_buff填充TCP头。sk_buff可以表示各个层的数据包，在应用层数据包叫data，在TCP层称为segment，在IP层叫作packet，在数据链路层叫frame

为什么全部数据包只用一个结构体描述？
因为协议栈采用的是分层结构，上层向下层传递时需要增加包头，下层向上层传递数据时又需要去掉包头，如果每一层都用一个结构体，层之间的传递就需要多次拷贝，大大降低CPU效率。于是，为了在层之间传递数据时不发生拷贝，只用sk_buff一个结构体来描述所有的网络包，只需要通过调整sk_buff中data的指针，比如：

- 当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加skb->data的值，来逐步剥离协议首部，即包头
- 当发送报文时，创建sk_buff结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少skb->data的值来增加协议首部

![image-20230601170324772](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230601170324772.png)

至此，传输层的工作都完成了。

然后交给网络层，在网络层中会做这些工作：选取路由（确认下一跳的IP）、填充IP头，netfilter过滤，对超过MTU大小的数据包进行分片。处理完这些工作后交给网络接口层处理。

网络接口层会通过ARP协议获得下一跳的MAC地址，然后对sk_buff填充帧头和帧尾，接着将sk_buff放到网卡的发送队列中。

这些准备工作做好后，会触发 软中断 告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取sk_buff，将这个sk_buff挂到RingBuffer中，接着将sk_buff数据映射到网卡可访问的内存DMA区域，最后触发真实的发送

当数据发送完成之后，工作并未结束，因为内存还没有清理干净。发送完成时，网卡设备会触发一个硬中断来释放内存，主要是释放sk_buff内存和清理RIngBuffer内存。

最后，当收到该TCP报文的ACK应答时，传输层就会释放原始的sk_buff。

> 发送网络数据的时候，涉及几次内存拷贝操作？

第一次，调用发送数据的系统调用时，内核会申请一个内核态的sk_buff内存，将用户待发送的数据拷贝到sk_buff内存，并将其加入到发送缓冲区

第二次，在使用TCP传输协议的情况下，从传输层进入网络层的时候，每一个sk_buff都会被克隆一个新的副本出来。副本sk_buff会被送往网络层，等它发送完的时候就会释放掉，然后原始的sk_buff还保留在传输层，目的是为了实现TCP的可靠传输，等收到这个数据包的ACK时，才会释放原始的sk_buff

第三次，当IP层发现sk_buff大于MTU时才需要进行拷贝。会再次申请额外的sk_buff，并将原来的sk_buff拷贝为多个小的sk_buff



## 二、HTTP篇

### 2.1 HTTP常见面试题

#### 2.1.1 HTTP基本概念

HTTP是超文本传输协议，也就是HyperText Transfer Protocol

HTTP的名字超文本传输协议可以拆分成三个部分：

- 超文本
- 传输
- 协议

1. 协议：

   HTTP协议是一个用在计算机世界里的协议，它使用计算机能够理解的语言确立了一种计算机之间的交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）

2. 传输：

   HTTP协议是一个双向协议，我们上网冲浪时，浏览器是请求方A，百度网站就是应答方B。双方约定用HTTP协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。

   ![image-20230607000036164](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230607000036164.png)

   数据虽然是在A和B之间传输，但允许中间有中转或接力

   在HTTP里，需要中间人遵从HTTP协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。

   HTTP是一个在计算机世界里专门用来在两点之间传输数据的约定和规范

3. 超文本：

   HTTP传输的内容是超文本

   互联网早期的时候只是简单的字符文字，但现在文本的涵义已经可以扩展为图片、视频、压缩包等，在HTTP眼里这些都算作文本

   超文本就是超越了普通文本的文本，它是文字、图片、视频等的混合体，最关键有超链接，能从一个文本跳转到另外一个超文本

   HTML就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们就是一个文字、有画面的网页了

**HTTP**是一个在计算机世界里专门在**两点**之间**传输**文字、图片、音频、视频等**超文本**数据的**约定和规范**

> 那HTTP是用于从互联网服务器传输超文本到本地浏览器的协议，这种说法正确吗？

这种说法是不正确的，因为也可以是 服务器<——>服务器，所以采用两点之间的描述会更准确



**HTTP常见的状态码有哪些？**

![image-20230607133210184](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230607133210184.png)

- **1xx**类状态码属于提示信息，是协议处理中的一种中间代码，实际用到的比较少

- 2xx类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态

  - **200OK**是最常见的成功状态码，表示一切正常。如果是非HEAD请求，服务器返回的响应头都会有body数据
  - **204 No Content**也是常见的成功状态码，与200OK基本相同，但响应头没有body数据
  - **206 Partial Content**是用于HTTP分块下载或断点续传，表示响应返回的body数据并不是资源的全部，而是其中一部分，也是服务器处理成功的状态

- **3xx**类状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是**重定向**

  - **301 Moved Permanently**表示永久重定向，说明请求的资源已经不存爱了，需改用新的 URL再次访问

  - **302 Found**表示临时重定向，说明请求的资源还在，但暂时需要另一个URL来访问

    301和302斗都会在响应头里使用字段Location，指明后续要跳转的URL，浏览器会自动重定向新的URL

  - **304 Not Modified**不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制

- **4xx**类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义

  - **400 Bad Request**表示客户端请求的报文有错误，但只是个笼统的错误
  - **403 Forbidden**表示服务器进制访问资源，并不是客户端的请求出错
  - **404 Not Found**表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端

- **5xx**类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务端的错误码

  - **500 Internal Server Error**与400类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道
  - **501 Not Implemened**表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思
  - **502 Bad Gateway**通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误
  - **503 Service Unavailable**表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思



**HTTP常见字段有哪些？**

- Host字段：客户端发送请求时，用来指定服务器的域名

  ![](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230607222854912.png)

  有了Host字段，就可以将请求发往同一台服务器上的不同网站

- Cotent-Length字段

  服务器在返回数据时，会有Cotent-Length字段，表明本次回应的数据长度

  ![image-20230607223258960](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230607223258960.png)

  上面是告诉浏览器，本次服务器回应的数据长度是1000个字节，后面的字节就属于下一个回应了

  HTTP是基于TCP传输协议进行通信的，而使用了TCP传输协议，就会存在一个“粘包”问题，HTTP协议通过设置回车符、换行符作为HTTP header的边界，通过Cotent-Length字段作为HTTP body的边界，这两个方式都是为了解决“粘包”的问题。

- Connection字段

  Connection字段最常用于客户端要求服务器使用 HTTP长连接 机制，以便其他请求复用

  ![image-20230607225053329](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230607225053329.png)

  HTTP长连接的特点是，只要任意一段没有明确提出断开连接，则保持TCP连接状态

  ![HTTP 长连接](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/d2b20d1cc03936332adb2a68512eb167-20230309231005893.png)

  HTTP/1.1版本的默认连接都是长连接，但为了兼容老版本的HTTP，需要指定Connection首部字段的值为Keep-Alive

  ```
  Connection:Keep-Alive
  ```

  开启了HTTP Keep-Alive机制后，连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务端提出断开连接

- Content-Type字段

  Content-Type字段用于服务器回应时，告诉客户端，本次数据是什么格式

  ```
  Content-Type:text/html;Charset=utf-8
  ```

  上面的类型表明，发送的是网页，而且编码是UTF-8

  客户端请求时，可以使用Accept字段表明自己可以接受哪些数据格式

  ```
  Accept:*/*
  ```

- Content-Encoding字段

  Content-Encoding字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式

  ![image-20230607231446740](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230607231446740.png)

  ```
  Content-Encoding:gzip
  ```

  上面表示服务器返回的数据采用了gzip方式压缩，告知客户端需要用此方式解压

  客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法

  ```
  Accept-Encoding:gzip,deflate
  ```



#### 2.1.2 GET与POST

****

**GET和POST有什么区别？**

根据RFC规范，**GET的语义是从服务器获取指定的资源**，这个资源可以是静态的文本、页面、图片视频等。GET请求的参数位置一般是写在URL中，URL规定只能支持ASCII，所以GET请求的参数只允许ASCII字符，而且浏览器会对URL的长度有限制（HTTP协议本身对URL长度并没有做任何规定）



根据RFC规范，**POST的语义是根据请求负荷（报文body）对指定的资源做出处理**，具体的处理方式可以视资源类型而不同。POST请求携带数据的位置一般是写在报文body中，body中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对body大小做限制。

比如，在文章底部，敲入留言后点击提交，浏览器就会执行一次POST请求，把留言文字放进了报文body里，然后拼接好POST请求头，通过TCP协议发送给服务器。



**GET和POST方法都是安全和幂等的吗？**

安全和幂等的概念：

- 安全：在HTTP协议里，所谓的安全是指请求方法不会破坏服务器上的资源
- 幂等：所谓的幂等，意思是多次执行相同的操作，结果都是相同的

从RFC规范定义的语义来看：

- **GET方法就是安全且幂等的**，因为它是只读操作，无论操作多少次，服务器上的数据都是安全的，且每次结果都是相同的。所以，**可以对GET请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如Nginx），而且在浏览器中GET请求可以保存为书签**
- **POST**因为是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，**浏览器一般不会缓存POST请求，也不能把POST请求保存为书签**



**总结：**

GET是安全、幂等的

POST是不安全且不幂等的



上面是根据RFC规范定义的语义分析的

但在实际过程中，开发者不一定会按照RFC规范定义的语义来实现GET和POST方法，比如：

- 可以用GET方法实现新增或删除数据的请求，这样实现的GET方法自然就不是安全和幂等。 
- 可以用POST方法实现查询数据的请求，这样实现的POST方法自然就是安全和幂等。

HTTP传输的内容都是明文的，要避免传输过程中数据被窃取，就要使用HTTPS协议，这样所有的HTTP的数据都会被加密传输



> GET请求可以带body吗？

RFC规范并没有规定GET请求不能带body的。理论上，任何请求都可以带body，。只是因为RFC规范定义的GET请求是获取资源，所以根据这个语义不需要用到body。

另外，URL中的查询参数也不是GET所独有的，POST请求的URL中也可以有参数。



#### 2.1.3 HTTP缓存技术

**HTTP缓存有哪些实现方式？**

对于一些具有重复性的HTTP请求，比如每次得到的数据都是一样的，我们可以把这对 请求-响应 的数据都缓存在本地，那么下次就直接读取本地的数据，不必再通过网络获取服务器的响应了，这样的话HTTP/1.1的性能肯定肉眼可见的提升。



所以，避免发送HTTP请求的方法就是通过缓存技术，HTTP设计者早在之前就考虑到了这点，因此HTTP协议的头部有不少是针对缓存的字段



HTTP缓存有两种实现方式，分别是强制缓存和协商缓存

**什么是强制缓存？**

强制缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在浏览器这边

![image-20230711114031927](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711114031927.png)

如果HTTP相应头部同时有Cache-control和Expires字段的话，Cache-control的优先级高于Expires



Cache-control选项更多一些，设置更加精细，所以建议使用Cache-control来实现强缓。具体的实现流程如下：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response头部加上Cache-control，Cache-control中设置了过期时间大小
- 浏览器再次请求访问服务器中的资源时，会先通过请求资源的时间与Cache-control中设置的过期时间大小，来计算该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器
- 服务器再次收到请求后，会再次更新Response头部的Cache-control



**什么是协商缓存？**

当我们在浏览器使用开发者工具的时候，可能会看到某些请求的响应码是304，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。

![image-20230711120114319](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711120114319.png)

协商缓存可以基于两种头部来实现。

第一种：请求头部中的If-Modified-Since字段与响应头部中的Last-Modified字段实现，这两个字段的意思是：

- 响应头部中的Last-Modified：表示这个响应资源最后修改时间
- 请求头部中的If-Modified-Since：当资源过期了，发现响应头部中具有Last-Modified声明，则再次发起请求的时候带上Last-Modified的时间，服务器收到请求后发现有If-Modified-Since则与被请求资源的最后修改时间（Last-Modified）对比，如果最后修改时间较晚，说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较早，说明资源无新修改，响应HTTP 304 走缓存

第二种：请求头部中的If-None-Match字段与响应头部中的ETag字段，这两个字段的意思是：

- 响应头部中Etag：唯一标识响应资源
- 请求头部中的If-None-Match：当资源过期时，浏览器发现响应头里有Etag，则再次向服务器发起请求时，会将请求头If-None-Match值设置为Etag的值，服务器收到请求后进行比对，如果资源没有变化返回304，如果资源变化了返回200

第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件是否被修改，避免由于时间篡改导致的不可靠问题



如果在第一次请求资源的时候，服务端返回的HTTP相应头部同时有Etag和Last-Modified字段，那么客户端再下一次请求的时候，如果带上Etag和Last-Modified字段信息给服务端，**这时Etag的优先级更高**，也就是服务端会判断Etag是否变化了，如果Etag有变化就不用再判断Last-Modified了，如果Etag没有变化，就再看Last-Modified



**为什么ETag的优先级更高？**

这是因为ETag主要能解决Last-Modified几个比较难以解决的问题：

1. 在没有修改文件内容情况下文件的修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求
2. 可能有些文件是在秒级以为修改的，If-Modified-Since能检查到的粒度是秒级的，使用ETag就能够保证这种需求下1秒内能刷新多次
3. 有些服务器不能精确获取文件的最后修改时间

注意，协商缓存这两个字段都需要配合强制缓存中Cache-control来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求



强制缓存和协商缓存的工作流程：

![image-20230711121431797](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711121431797.png)



当使用ETag字段实现的协商缓存的过程：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在Response头部加上ETag唯一标识，这个唯一标识的值是根据当前请求的资源生成的
- 当浏览器再次请求访问服务器中的该资源时，首先会检查强制缓存是否过期
  - 如果没有过期，则直接使用本地缓存
  - 如果缓存过期了，会在Request头部加上If-None-Match字段，该字段的值就是ETag唯一标识
- 服务器再次收到请求后，会根据请求中的If-None-Match值域当前请求的资源生成的唯一标识进行比较
  - 如果值相等，则返回304 Not Modified，不会返回资源
  - 如果不想打，则返回200状态码和返回资源，并在Response头部加上新的ETag唯一标识
- 如果浏览器收到304的请求响应状态码，则会从本地缓存中加载资源，否则更新资源



#### 2.1.4 HTTP特性

到目前为止，HTTP常见的版本有HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的HTTP特性不一样



**HTTP/1.1的优点有哪些？**

HTTP最突出的优点是 简单、灵活和易于扩展、应用广泛和跨平台

1. 简单

   HTTP基本的保温格式就是header+body，头部信息也是key-value简单文本的形式，易于理解，降低了学习和使用的门槛

2. 灵活和易于扩展

   HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有固定死，都允许开发人员自定义和扩充

   同时HTTP由于是工作在应用层（OSI第七层），则它下层可以随意变化，比如：

   - HTTPS就是在HTTP与TCP层之间增加了SSL/TLS安全传输层
   - HTTP/1.1和HTTP/2.0传输协议使用的是TCP协议，而到了HTTP/3.0传输协议改用了UDP协议

3. 应用广泛和跨平台

   互联网发展至今，HTTP的应用范围十分广泛，从台式机的浏览器到手机上的各种APP，各种HTTP的应用遍地开花，同时具有跨平台的优越性



**HTTP/1.1的缺点有哪些？**

HTTP协议里有优缺点一体的双刃剑，分别是 无状态、明文传输，同时还有一大缺点 不安全

1. 无状态双刃剑

   无状态的好处，因为服务器不会去记忆HTTP的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的CPU和内存用来对外提供服务

   无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦

   例如登录->添加购物车->下单->结算->支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息

   这样每操作一次，都要验证信息，购物体验大打折扣

   对于无状态的问题，解决方案有很多种，其中比较简单的方式是用Cookie技术。

   Cookie通过在请求和响应报文中写入Cookie信息来控制客户端的状态

   相当于，在客户端第一次请求后，服务器会下发一个装有客户信息的小贴纸，后续客户端请求服务器的时候，带上小贴纸，服务器就能认得了

   ![image-20230711154530252](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711154530252.png)

2. 明文传输双刃剑

   明文意味着在传输过程中的信息，是可方便阅读的，比如Wireshark抓包都可以直接肉眼查看，为调试工作带来了极大的便利性

   但是正是这样，HTTP的所有信息都暴露在外，相当于信息裸奔。在传输的漫长的过程中，信息的内容毫无隐私可言，很容易就能被窃取，如果里面有隐私信息，就十分危险。

3. 不安全

   HTTP比较严重的确定就是不安全：

   - 通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄露
   - 不验证通信方的身份，因此有可能遭遇伪装，比如，访问假的淘宝、拼多多
   - 无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染



HTTP的安全问题，可以用HTTPS的方式解决，也就是通过引入SSL/TLS层，使得在安全上达到了极致



**HTTP/1.1的性能如何？**

HTTP协议里是基于TCP/IP，并且使用了 请求-应答 的通信模式，所以性能的关键在这两点里

1. 长连接

   早期HTTP/1.0性能上的一个很大的问题，就是每发起一个请求，都要新建一次TCP连接（三次握手），而且是串行请求，做了无谓的TCP连接建立和断开，增加了通信开销

   为了解决上述TCP连接问题，HTTP/1.1提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务端的负载

   持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态

   ![image-20230711160221527](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711160221527.png)

   当然，如果某个HTTP长连接超过一定时间没有任何数据交互，服务端就会主动断开这个连接

2. 管道网络传输

   HTTP/1.1采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能

   即可在同一个TCP连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间

   ![image-20230711163847323](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711163847323.png)

   实际上HTTP/1.1管道化技术不是默认开启，而且浏览器基本都没有支持。有这个功能但是没有被使用

3. 对头阻塞

   **请求-应答的模式会造成HTTP的性能问题，为什么呢？**

   因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是 队头阻塞

   ![image-20230711164217737](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711164217737.png)



#### 2.1.5 HTTP与HTTPS

**HTTP与HTTPS有哪些区别？**

- HTTP是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS则解决HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输。
- HTTP连接建立相对简单，TCP三次握手之后便可进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需进行SSL/TLS的握手过程，才可进入加密报文传输
- 两者的默认端口不一样，HTTP默认端口号是80，HTTPS默认端口号是443
- HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的



**HTTPS解决了HTTP的哪些问题？**

HTTP由于是明文传输，所以安全上存在以下三个风险：

- 窃听风险：比如通信链路上可以获取通信内容
- 篡改风险：比如强制植入垃圾广告
- 冒充风险：比如冒充淘宝网站

![image-20230711210706199](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711210706199.png)

HTTPS在HTTP与TCP层之间加入了SSL/TLS协议，可以很好的解决了上述的风险：

- 信息加密：交互信息无法被窃取，但你的号会因为自身忘记而没
- 校验机制：无法篡改通信内容，篡改了就不能正常显示
- 身份证书：证明淘宝是真的淘宝网



> HTTPS是如何解决上面的三个风险的？

- 混合加密的方式实现信息的机密性，解决了窃听的风险
- 摘要算法的方式来实现完整性，它能够为数据生成独一无二的“指纹”，指纹用于校验数据的完整性，解决了篡改的风险
- 将服务器公钥放入到数字证书中，解决了冒充的风险



1. 混合加密

   ![image-20230711211645615](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711211645615.png)

   HTTPS采用的是对称加密和非对称加密的结合的混合加密方式：

   - 在通信建立前采用非对称加密的方式交换会话秘钥，后续就不再使用非对称加密
   - 在通信过程中全部使用对称加密的会话秘钥的方式加密明文数据

   采用混合加密的原因：

   - 对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换
   - 非对称加密使用两个密钥，公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但是速度慢

2. 摘要算法+数字签名

   ![image-20230711212052243](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711212052243.png)

   ![image-20230711212305899](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711212305899.png)

   ![image-20230711212511270](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711212511270.png)

   私钥由服务端保管，然后服务端会向客户端颁发对应的公钥。如果客户端收到的信息，能被公钥解密，说明该消息是由服务器发送的。

   ![image-20230711212639594](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711212639594.png)

3. 数字证书

   ![image-20230711212730155](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711212730155.png)

   ![image-20230711212852077](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711212852077.png)

   ![image-20230711212952728](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711212952728.png)



**HTTPS是如何建立连接的？期间交互了什么？**

SSL/TLS协议基本流程：

- 客户端向服务器索要并验证服务器的公钥
- 双方协商生产会话秘钥
- 双方采用会话秘钥进行加密通信

前两步也就是SSL/TLS的建立过程，也就是TLS握手阶段，设计四次通信，使用不同的密钥交换算法，TLS握手流程也会不一样，现在常用的密钥交换算法有两种：RSA算法和ECDHE算法



基于RSA算法的TLS握手过程，如下图：

![image-20230711213903520](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711213903520.png)

![image-20230711213927345](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711213927345.png)



TLS协议建立的详细流程：

![image-20230711214033405](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214033405.png)

![image-20230711214127033](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214127033.png)

![image-20230711214153668](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214153668.png)

![image-20230711214253972](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214253972.png)

![image-20230711214348287](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214348287.png)

不过，基于RSA算法的HTTPS存在前向安全的问题：如果服务端的私钥泄露了，过去被第三方截获的所有TLS通讯密文都会被破解

为了解决这个问题，后面就出现了ECDHE秘钥协商算法，我们现在大多数网站使用的正是ECDHE秘钥协商算法



> 客户端校验数字证书的流程是怎样的？

![image-20230711214612957](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214612957.png)

CA签发证书的过程，如上图左边部分：

![image-20230711214727392](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214727392.png)

客户端校验服务端的数字证书的过程，如上图右边部分：

![image-20230711214806377](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214806377.png)



![image-20230711214858900](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214858900.png)

![image-20230711214933629](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214933629.png)

![image-20230711214945988](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711214945988.png)

![image-20230711215031400](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711215031400.png)

证书信任链：

![image-20230711215108477](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711215108477.png)

操作系统里一般都会内置一些根证书

![image-20230711215201934](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711215201934.png)



为什么需要证书链这么麻烦的流程？Root CA为什么不直接颁发证书，而是要搞这么多中间层级呢？

这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，整个信任链都会有问题。（不要把鸡蛋都放在同一个篮子里）



**HTTPS的应用数据是如何保证完整性的？**

TLS在实现上分为握手协议和记录协议两层：

- TLS握手协议就是我们前面说的TLS四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即HTTP数据）
- TLS记录协议负责保护应用程序数据并验证其完整性和来源，所以对HTTP数据加密是使用记录协议



TLS记录协议主要负责消息（HTTP数据）的压缩，加密及数据的认证，过程如下图：

![image-20230711215657730](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711215657730.png)

具体过程如下：

![image-20230711215732744](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711215732744.png)

![image-20230711215740066](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711215740066.png)

记录协议完成后，最终的报文数据将传递到传输控制协议（TCP）层进行传输



**HTTPS一定安全可靠吗？**

> 字节一面问题：客户端通过浏览器向服务端发起HTTPS请求时，被假基站转发到了一个中间人服务器，于是客户端是和中间人服务器完成了TLS握手，然后这个中间人服务器再与真正的服务器完成TLS握手。

![image-20230711220107640](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711220107640.png)

具体过程如下：

![image-20230711220406232](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711220406232.png)

![image-20230711220424646](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711220424646.png)

![image-20230711220531013](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711220531013.png)

![image-20230711220551462](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711220551462.png)

![image-20230711220608090](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711220608090.png)



> 为什么抓包工具能截取HTTPS数据？

![image-20230711220746570](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711220746570.png)



> 如何避免被中间人抓取数据？

![image-20230711220823866](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711220823866.png)



#### 2.1.6 HTTP/1.1、HTTP/2、HTTP/3演变

**HTTP/1.1相比HTTP/1.0提高了什么性能？**

![image-20230711221035382](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221035382.png)



**HTTP/2做了什么优化？**

HTTP/2协议是基于HTTPS的，所以HTTP/2的安全性也是有保障的

![image-20230711221115538](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221115538.png)



HTTP/2相比HTTP/1.1性能上的改进：

- 头部压缩
- 二进制格式
- 并发传输
- 服务器主动推送资源

![image-20230711221230679](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221230679.png)

![image-20230711221238031](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221238031.png)

![image-20230711221255590](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221255590.png)

![image-20230711221314999](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221314999.png)

![image-20230711221344484](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221344484.png)

![image-20230711221418545](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221418545.png)

![image-20230711221523801](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221523801.png)

![image-20230711221534219](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221534219.png)

![image-20230711221553330](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221553330.png)

![image-20230711221604803](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221604803.png)

![image-20230711221618865](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221618865.png)

![image-20230711221639269](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221639269.png)

![image-20230711221649348](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221649348.png)

![image-20230711221716368](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221716368.png)



> HTTP/2有什么缺陷？

![image-20230711221756505](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221756505.png)

![image-20230711221922146](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711221922146.png)



**HTTP/3做了哪些优化？**

HTTP/3把HTTP下层的TCP协议改成了UDP

![image-20230711222037983](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711222037983.png)

![image-20230711222103913](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711222103913.png)

![image-20230711222118741](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711222118741.png)

![image-20230711222209090](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711222209090.png)

![image-20230711222247637](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711222247637.png)

![image-20230711222317888](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230711222317888.png)



### 2.2 HTTP/1.1如何优化？

可以从下面这三种优化思路来优化HTTP/1.1协议：

- 尽量避免发送HTTP请求
- 在需要发送HTTP请求时，考虑如何减少请求次数
- 减少服务器的HTTP响应的数据大小



#### 2.2.1 如何避免发送HTTP请求？

不是不发送HTTP请求，而是对于一些具有重复性的HTTP请求，比如每次请求得到的数据都一样的，可以把这对请求-响应的数据都缓存在本地，下次就直接读取本地的数据，不必再通过网络获取服务器的响应了



所以，避免发送HTTP请求的方法是通过缓存技术，HTTP设计者早在之前就考虑到了这点，因此HTTP协议的头部有不少是针对缓存的字段



> 那缓存时如何做到的呢？

客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的URL作为key，而响应作为value，两者形成映射关系



这样当后续发起相同的请求时，就可以先在本地磁盘上通过key查到对应的value，也就是响应，如果找到了，就直接从本地获取该响应。如下图：

![image-20230722221630682](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230722221630682.png)

但又有一个问题，如果缓存的响应不是最新的，而客户端不知情，那该怎么办呢？

解决方法：服务器在发送HTTP响应时，会估算一个过期的时间，并把这个信息放到响应头部中，这样客户端在查看响应头部的信息时，一旦发现缓存的响应是过期的，则就会重新发送网络请求



如果客户端从第一次请求得到的响应头部中发现该响应过期了，客户端重新发送请求，假设服务器上的资源并没有变更，服务器的响应还需要带上这个资源吗？

很明显不带的话，可以提高HTTP协议的性能，具体如何做到呢？

只要客户端在重新发送请求时，在请求的Etag头部带上第一次请求的响应头部中的摘要，这个摘要是唯一标识响应的资源，当服务器收到请求后，会将本地资源的摘要与请求中的摘要作比较

如果不同，说明客户端的缓存就已经没有价值了，服务器在响应中带上最新的资源

如果相同，说明客户端的缓存还是可以继续使用的，那么服务器仅返回不含有包体的304 Not Modified响应，告诉客户端仍然有效，这样就可以减少响应资源在网络中传输的延时，如下图：

![image-20230722222249658](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230722222249658.png)

缓存是性能优化的一把万能钥匙，小到CPU Cache、Page Cache、Redis Cache，大到HTTP协议的缓存



#### 2.2.2 如何减少HTTP请求次数？

减少HTTP请求次数自然也就提升了HTTP性能，可以从这3个方面入手：

- 减少重定向请求次数
- 合并请求
- 延迟发送请求



**减少重定向请求次数**

> 什么是重定向请求？

服务器上的一个资源可能由于迁移、维护等原因从url1移至url2,后，而客户端不值钱，它还是继续请求url1，这时服务器不能粗暴地返回错误，而是通过302响应码和Location头部，告诉客户端该资源已经迁移至url2了，于是客户端需要再发送url2请求以获得服务器的资源



服务端一方往往不只有一台服务器，比如源服务器上一级是代理服务器，然后代理服务器才与客户端通信，这时客户端重定向就会导致客户端与代理服务器之间需要两次消息传递，如下图：

![image-20230723180111278](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723180111278.png)

如果重定向的工作交给由代理服务器完成，就能减少HTTP请求次数了，如下图：

![image-20230723180143598](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723180143598.png)

而当代理服务器知晓了重定向规则后，可以进一步减少消息传递次数，如下图：

![image-20230723180231326](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723180231326.png)



除了302重定向响应码，还有其他一些重定向的响应码，如下图：

![image-20230723180343773](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723180343773.png)

其中，301和308响应码是告诉客户端可以将重定向响应缓存到本地磁盘，之后客户端就自动用url2替代url1访问服务器的资源了



**合并请求**

把多个小文件的请求合并成一个大的请求，虽然传输的总资源还是一样，但是减少了请求，也就意味着减少了重复发送HTTP头部



![image-20230723180542626](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723180542626.png)



![image-20230723180715092](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723180715092.png)

![image-20230723180826640](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723180826640.png)



**延迟发送请求**

![image-20230723181536168](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723181536168.png)



#### 2.2.3 如何减少HTTP响应的数据大小

对响应的资源进行压缩，一般由两种压缩方式：

- 无损压缩
- 有损压缩



**无损压缩**

无损压缩是指资源经过压缩后，信息不被破坏，还能完全恢复到压缩前的原样，适合用在文本文件、程序可执行文件、程序源代码

![image-20230723181814009](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723181814009.png)

![image-20230723181840329](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723181840329.png)



**有损压缩**

解压的数据会与原始数据不同但是非常接近

有损压缩主要将次要的数据舍弃，牺牲一些质量来减少数据量、提高压缩比，这种方法经常用于压缩多媒体数据，比如音频、视频、图片



![image-20230723182023813](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723182023813.png)

![image-20230723182233516](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230723182233516.png)



### 2.3 HTTPS RSA握手解析

#### 2.3.1 握手过程

![image-20230727141154863](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727141154863.png)

![image-20230727141300483](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727141300483.png)

![image-20230727141430403](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727141430403.png)



#### 2.3.2 RSA握手过程

![image-20230727141625304](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727141625304.png)

![image-20230727141704718](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727141704718.png)

![image-20230727141722679](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727141722679.png)



**TLS第一次握手**

客户端首先发一个 Client Hello消息（客户端使用的TLS版本号、支持的密码套件列表、生成的随机数（这个随机数会被服务端保留，它是生成对称加密密钥的材料之一））



**TLS第二次握手**

服务端收到客户端的Client Hello之后，会确认TLS版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成随机数

接着，返回 Server Hello 消息（服务器确认的TLS版本号，随机数，从客户端的密码套件列表选择了一个合适的密码套件）

![image-20230727142238939](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727142238939.png)

密码套件格式：密码交换算法+签名算法+对称加密算法+摘要算法



目前为止，客户端和服务端就已确认了TLS版本和使用的密码套件，并且各自生成的随机数

这两个随机数是后续作为生成会话密钥的条件，会话密钥就是数据传输时，所使用的对称加密密钥



然后，服务端为了证明自己的身份，发送 Server Certificate 给客户端，这个消息里含有数字证书

随后，服务端发了 Server Hello Done 消息，目的是告诉客户端，已经把该给的材料交付完毕了



**客户端验证证书**

> 客户端怎么校验数字证书？

**数字证书和CA机构**

![image-20230727142704521](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727142704521.png)

![image-20230727142734637](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727142734637.png)



**数字证书签发和验证流程**

![image-20230727142832232](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727142832232.png)



**证书链**

a信任b，b信任c，所以a也信任c



**TLS第三次握手**

![image-20230727143053116](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727143053116.png)

![image-20230727143135421](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727143135421.png)



**TLS第四次握手**

![image-20230727143216418](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727143216418.png)



#### 2.3.3 RSA算法的缺陷

![image-20230727143255564](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727143255564.png)

### 2.4 HTTPS ECDHE握手解析

HTTPS常用的密钥交换算法有两种，分别是RSA和ECDHE算法

RSA是比较传统的密钥交换算法，不具备前向安全的性质，因此现在很少服务器使用

ECDHE算法具有前向安全，所以被广泛使用



#### 2.4.1 离散对数

ECDHE密钥协商算法是DH算法演进过来的
DH算法是非对称加密算法，因此它可以用于密钥交换，该算法的核心数学思想是离散对数

![image-20230725003935998](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725003935998.png)



#### 2.4.2 DH算法

![image-20230725004153201](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725004153201.png)

![image-20230725004415470](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725004415470.png)



#### 2.4.3 DHE算法

根据私钥生成的方式，DH算法分为两种实现：

- static DH算法：已废弃
- DHE算法：常用

![image-20230725004903807](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725004903807.png)



#### 2.4.4 ECDHE算法

DHE算法由于计算性能不佳，因为需要做大量的乘法，为了提升DHE算法的性能，所以出现了ECDHE算法



ECDHE算法是在DHE算法的基础上利用了ECC椭圆曲线特性，用更少的计算量计算出公钥，以及最终的会话密钥



![image-20230725005149622](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725005149622.png)

双方根据自己的私钥和对方的公钥都可以得出一个相同的值，这个值就作为它们之间的共享密钥。而第三方是很难通过这些公开的信息，比如公钥等来反推出私钥的，所以就具有安全性，因此也就不好得出共享密钥了



#### 2.4.5 ECDHE握手过程

![image-20230725005330863](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725005330863.png)



**TLS第一次握手**

客户端会首先发一个 Client Hello 消息，消息里面有客户端使用的TLS版本号、支持的密码套件列表，以及生成的随机数(Client Random)

![image-20230725005722464](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725005722464.png)



**TLS第二次握手**

服务端收到客户端的打招呼，返回 Server Hello 消息，消息里面有服务器确认的TLS版本号，也给出了一个随机数(Server Random)，然后从客户端的密码套件列表选择了一个合适的密码套件

![image-20230725005945304](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725005945304.png)

TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384：

- 密钥协商算法使用ECDHE
- 签名算法使用RSA
- 握手后的通信使用AES对称算法，密钥长度256位，分组模式是GCM
- 摘要算法使用SHA384



![image-20230725010222095](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725010222095.png)

这个过程服务器做了三件事：

- 选择了名为x25519的椭圆曲线，选好了椭圆曲线相当于椭圆曲线基点G也定好了，这些都会公开给客户端
- 生成随机数作为服务端椭圆曲线的私钥，保留到本地
- 根据基点G和私钥计算出服务端的椭圆曲线公钥，这个会公开给客户端

为了保证这个椭圆曲线的公钥不被第三方篡改，服务端会用RSA签名算法给服务端的椭圆曲线公钥做个签名

![image-20230725010506437](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725010506437.png)



**TLS第三次握手**

![image-20230725010637934](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725010637934.png)

![image-20230725010709340](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725010709340.png)



**TLS第四次握手**

![image-20230725010808412](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230725010808412.png)



### 2.5 HTTPS如何优化？

由裸数据传输的HTTP协议转成加密数据传输的HTTPS协议，给应用数据套了个保护伞，提高安全性的同时也带来了性能消耗



因为HTTPS相比HTTP协议多一个TLS协议握手过程，目的是为了通过非对称加密握手协商或者交换出对称加密密钥，这个过程最长可以花费掉2RTT，接着后续传输的应用数据都得使用对称加密密钥来加密/解密



#### 2.5.1 分析性能损耗

产生性能消耗的两个环节：

- TLS协议握手过程
- 握手后的对称加密报文传输

![image-20230727181912930](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727181912930.png)



#### 2.5.2 硬件优化

![image-20230727182010369](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727182010369.png)

![image-20230727182024495](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727182024495.png)



#### 2.5.3 软件优化

![image-20230727182118205](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727182118205.png)



#### 2.5.4 协议优化

协议的优化就是对密钥交换过程进行优化



**密钥交换算法优化**

![image-20230727182229800](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727182229800.png)

RSA的TLS握手过程：2RTT，不具备前向安全性

ECDHE的TLS握手过程：1RTT，具备前向安全性



**TLS升级**

![image-20230727182347518](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727182347518.png)

![image-20230727182436654](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727182436654.png)

![image-20230727182504526](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727182504526.png)



#### 2.5.5 证书优化

对于证书的优化，可以有两个方向：

- 证书传输
- 证书验证



**证书传输优化**

![image-20230727182631872](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727182631872.png)



**证书验证优化**

![image-20230727182858489](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727182858489.png)



**CRL**

![image-20230727182921778](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727182921778.png)



**OCSP**

![image-20230727183031765](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727183031765.png)



**OCSP Stapling**

为了解决这一个网络开销，就出现了OCSP Stapling，原理是：服务器向CA周期性地查询证书状态，获得一个带有时间戳和签名的响应结果并缓存它

![image-20230727183200209](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727183200209.png)



#### 2.5.6 会话复用

![image-20230727183250128](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727183250128.png)



**Session ID**

![image-20230727183617372](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727183617372.png)



**Session Ticket**

![image-20230727183926056](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727183926056.png)

![image-20230727183952258](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727183952258.png)

![image-20230727184038462](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727184038462.png)

避免重放攻击的方式就是需要对会话密钥设定一个合理的过期时间



**Pre-shared Key**

![image-20230727184246741](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727184246741.png)

![image-20230727184315021](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230727184315021.png)



### 2.6 HTTP/2牛逼在哪？

#### 2.6.1 HTTP/1.1协议的性能问题

对HTTP/1.1协议优化的手段只是在“外部”做优化，`而一些关键的地方，比如请求-响应模型、头部巨大且重复、并发连接耗时、服务器不能主动推送等，要改变这些必须重新设计HTTP协议，于是HTTP/2就出来了`



#### 2.6.2 兼容HTTP/1.1

> HTTP/2是怎么做的？

1. HTTP/2没有在URI里引入新的协议名，仍然用`http://`表示明文协议，用`https://`表明加密协议，于是只需要浏览器和服务器在背后自动升级协议，这样可以让用户意识不到协议的升级，很好地实现了协议的平滑升级
2. 只在应用层做了改变，还是基于TCP协议传输，应用层方面为了保持功能上的兼容，HTTP/2把HTTP分解成了`语义`和`语法`两个部分，`语义`层不做修改，与HTTP/1.1完全一致，比如请求方法、状态码、头字段等规则保留不变。但是，HTTP/2在`语法`层面做了很多改造，基本改变了HTTP报文的传输格式



#### 2.6.3 头部压缩

![image-20230730161130192](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730161130192.png)



**静态表编码**

HTTP/2为高频出现在头部的字符串和字段建立了一张静态表，它是写入到HTTP/2框架里的，不会变化的，静态表里共有61组，如下：

![img](https://camo.githubusercontent.com/fc9933adbf417e813375a55bad191a445a9ff04166269d75ba084b75823c3991/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470322f2545392539442539392545362538302538312545382541312541382e706e67)

![image-20230730161407702](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730161407702.png)

![image-20230730161704201](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730161704201.png)

![image-20230730161908348](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730161908348.png)

![img](https://camo.githubusercontent.com/66f54143bf0f8d4fa96b649bcffe64f8df59bf042f3772d079d47d5496040f96/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470322f6e6768747470782e706e67)

![image-20230730162010474](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730162010474.png)



**动态表编码**

![image-20230730162113682](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730162113682.png)

![img](https://camo.githubusercontent.com/70960859f8efdc1f4f20113842a7b1175a359fbc1774e1803271a90cec97f8da/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470322f2545352541342542342545392538332541382545372542432539362545372541302538312e706e67)



#### 2.6.4 二进制帧

![image-20230730162246364](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730162246364.png)

![image-20230730162324266](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730162324266.png)

![image-20230730162333725](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730162333725.png)

![image-20230730162435315](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730162435315.png)

![image-20230730162608971](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730162608971.png)



#### 2.6.5 并发传输

![image-20230730162807211](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730162807211.png)

![img](https://camo.githubusercontent.com/eac74b0353c82f43301e48df402dceba83c7cfc652cc1160e62cba22b08042df/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470322f73747265616d2e706e67)

![image-20230730162902625](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730162902625.png)

![img](https://camo.githubusercontent.com/128362dd941849f0b1f34f32e80d8ca2c4c1fdb2cb454be65adc99da2c94470b/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470322f73747265616d322e706e67)

![image-20230730163115704](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730163115704.png)

![img](https://camo.githubusercontent.com/dbc0b26395aeefa91d48c1e7dc38d2497096e62e2e6e2e816e9a5caba039c5f6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f38333434353538316461666534303964386366643263353733623237383161632e706e67)

![image-20230730163224776](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730163224776.png)



#### 2.6.6 服务器主动推送资源

![image-20230730163337962](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730163337962.png)

![image-20230730163355352](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730163355352.png)

![image-20230730163413217](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730163413217.png)

![img](https://camo.githubusercontent.com/0c97615e843d3d76e7b1c152848d479b39927c79d983fdb0610980bdcf0632fb/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470322f70757368322e706e67)

![image-20230730163447910](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730163447910.png)



#### 2.6.7 总结

![image-20230730163555825](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730163555825.png)

![image-20230730163621010](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230730163621010.png)



### 2.7 HTTP/3强势来袭

#### 2.7.1 美中不足的HTTP/2

![image-20230802162201331](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802162201331.png)



**队头堵塞**

![image-20230802162302296](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802162302296.png)

![image-20230802162350490](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802162350490.png)



**TCP与TLS的握手时延迟**

![image-20230802162614761](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802162614761.png)



**网络迁移需要重新连接**

![image-20230802162800996](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802162800996.png)



#### 2.7.2 QUIC协议的特点

![image-20230802162849284](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802162849284.png)

**无队头阻塞**

![image-20230802163010296](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802163010296.png)

QUIC连接上的多个Stream之间都是独立的，但是某个流中的数据包丢了，即使该流的其他数据包到达了，数据也无法被HTTP/3获取



**更快的连接建立**

![image-20230802163330838](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802163330838.png)

![img](https://camo.githubusercontent.com/c10cd44d6a90ef3190b4cb138dd18303c8035476eff7b2976bccb336a0797610/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470332f302d7274742e676966)



**连接迁移**

![image-20230802163646084](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802163646084.png)



#### 2.7.3 HTTP/3协议

![image-20230802163820945](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802163820945.png)

![image-20230802163913676](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802163913676.png)



#### 2.7.4 总结

![image-20230802164030632](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230802164030632.png)



### 2.8 既然有HTTP协议，为什么还要有RPC？

#### 2.8.1 从TCP聊起

![image-20230803222419904](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803222419904.png)

![握手建立连接流程](https://cdn.xiaolincoding.com//mysql/other/23cc66a7f4cb06afe13842b4b339e28b.gif)

建立连接后，可以使用`send()`发送数据，`recv()`接收数据

但是仅凭这样一个纯裸的TCP连接，虽然可以做到收发数据了，但是会有问题



#### 2.8.2 使用纯裸TCP会有什么问题

TCP有三个特点，`面向连接、可靠、基于字节流`

![TCP 是什么](https://cdn.xiaolincoding.com//mysql/other/3fcad07ba7ae92299b32224da8583363.png)



字节流可以理解为一个双向的通道里流淌的数据，这个数据就是常说的二进制数据。纯裸TCP收发的这些01串之间是没有任何边界的，所以根本无法知道哪个地方才算一条完整消息

![01 二进制字节流](https://cdn.xiaolincoding.com//mysql/other/254d845f9de05c19536d8343d268595a.png)

![image-20230803225616578](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803225616578.png)

![消息边界长度标志](https://cdn.xiaolincoding.com//mysql/other/9428feed1ff22156fc136d17a129527b.png)

![image-20230803225717417](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803225717417.png)



#### 2.8.3 HTTP和RPC

![四层网络协议](https://cdn.xiaolincoding.com//mysql/other/da970d16a205fb48d6a8bea14498814d.png)

`TCP是传输层的协议`，而基于TCP造出来的HTTP和各类RPC协议，它们都只是定义了不同消息格式的`应用层协议`而已

![image-20230803225926810](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803225926810.png)

![image-20230803225954619](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803225954619.png)

![image-20230803230025787](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803230025787.png)



> 既然有HTTP协议，为什么还要有RPC？

![image-20230803230111045](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803230111045.png)



> 那既然有RPC了，为什么还要有HTTP呢？

![image-20230803230259132](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803230259132.png)



#### 2.8.4 HTTP和RPC有什么区别

- **服务发现**（找到服务对应的IP端口的过程）

  ![image-20230803230638554](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803230638554.png)

- **底层连接形式**

  ![image-20230803230901855](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803230901855.png)

- **传输的内容**

  ![image-20230803231033339](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803231033339.png)

  ![image-20230803231131043](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803231131043.png)

  ![image-20230803231244105](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803231244105.png)

  ![HTTP 原理](https://cdn.xiaolincoding.com//mysql/other/f4cef7331cabcfe56d9d6434f7ef907f.png)

  ![RPC 原理](https://cdn.xiaolincoding.com//mysql/other/12244fb0b19b2e61755fcab799198f68.png)

  ![image-20230803231346522](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803231346522.png)



#### 2.8.5 总结

![image-20230803231508522](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230803231508522.png)



### 2.9 既然有HTTP协议，为什么还要有WebSocket？

**问题：**`看起来服务器主动发消息给客户端的场景`，是怎么做到的？

#### 2.9.1 使用HTTP不断轮询

![image-20230805232651498](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805232651498.png)

![image-20230805232723515](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805232723515.png)



#### 2.9.2 长轮询

![image-20230805232823011](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805232823011.png)

![image-20230805232841965](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805232841965.png)

![image-20230805232932494](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805232932494.png)



#### 2.9.3 WebSocket是什么

![image-20230805233059522](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805233059522.png)

![图片](https://cdn.xiaolincoding.com//mysql/other/3bbe4c5db972513f912d30ba8cbddd65.png)



**怎么建立WebSocket连接**

![image-20230805233243208](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805233243208.png)

![image-20230805233305927](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805233305927.png)

![image-20230805233321186](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805233321186.png)

![image-20230805233336963](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805233336963.png)



**WebSocket抓包**

用wireshark抓个包，实际看下数据包的情况

![图片](https://cdn.xiaolincoding.com//mysql/other/f756ca625523f0f9d40a402465179bbe.png)

![image-20230805233453989](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805233453989.png)

![图片](https://cdn.xiaolincoding.com//mysql/other/82d65f08dad05e6b537ea06b94224a5f.png)

![image-20230805233534684](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805233534684.png)

![图片](https://cdn.xiaolincoding.com//mysql/other/382c7699530ea7e7b22f60bb68af21bd.png)

![image-20230805233806679](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805233806679.png)



**WebSocket的消息格式**

![image-20230805233859019](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805233859019.png)

![image-20230805233913710](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805233913710.png)

![image-20230805234039902](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805234039902.png)

![image-20230805234122527](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805234122527.png)

![image-20230805234202866](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805234202866.png)

![image-20230805234229833](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805234229833.png)

![image-20230805234314971](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805234314971.png)

![image-20230805234332253](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805234332253.png)



**WebSocket的使用场景**

![image-20230805234403625](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805234403625.png)



#### 2.9.4 总结

![image-20230805234516202](https://md-jomo.oss-cn-guangzhou.aliyuncs.com/IMG/image-20230805234516202.png)
